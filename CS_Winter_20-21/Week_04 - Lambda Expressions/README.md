# Задача 1
Напишете следните λ изрази:
 - идентитет;
 - еквивалент на функцията *f x = 2 * x*;
 - приема унарна процедура *g* и две числа и изважда *g(a)* от *g(b)*.

Пример:

    Ако подадем еквивалента на f, 4.5 и 5.2 на последния израз, резултатът е -1.4000000000000004.

# Задача 2
Дефинирайте процедура от по-висок ред, която приема унарна процедура и я връща приложена n пъти.

Примери:

    (= ((apply-n (λ (x) (* 2 x)) 5) 2) 64)
    (= ((apply-n (λ (x) (quotient x 10)) 2) 100) 1)

Как работи:

    Първо прилагаме 2 * x с x = 2, след това с x = (2 * 2) и т.н. Следователно получаваме: (((((2 * 2) * 2) * 2) * 2) * 2) => ((((4 * 2) * 2) * 2) * 2) => (((8 * 2) * 2) * 2) => ((16 * 2) * 2) => (32 * 2) => 64

# Задача 3
Да се дефинира:
 - *my-compose f g*: връща композицията на процедурите f и g
 - *my-negate p?*: приема предикат и връща неговото отрицание
 - *my-curry f x*: приема многоаргумента процедура f и първи аргумент x и връща процедурата, получена от частичното прилагане на x върху f

Примери:

    (= ((compose (λ (x) (- x 5)) (λ (x) (+ x 25))) 5) 25)
    (= ((negate (λ (x) (even? x))) 2) #f)
    (= ((my-curry (λ (x y) (+ (* 10 x) y)) 5) 10) 60)

# Задача 4
Ако *f* и *g* са числови функции, а *n* - естествено число, да се дефинира функция от по-висок ред *switch-sum f g n*, която връща като резултат функция, чиято стойност в дадена точка *x* е равна на *f(x)+g(f(x))+f(g(f(x)))+ ...* (сума от *n* събираеми). Подаваните параметри ще бъдат валидни.

Примери:

    (= ((switch-sum (λ (x) (+ x 1)) (λ (x) (* x 2)) 1) 2) 3)
    (= ((switch-sum (λ (x) (+ x 1)) (λ (x) (* x 2)) 2) 2) 9)
    (= ((switch-sum (λ (x) (+ x 1)) (λ (x) (* x 2)) 3) 2) 16)
    (= ((switch-sum (λ (x) (+ x 1)) (λ (x) (* x 2)) 4) 2) 30)

# Задача 5
Да се дефинира процедура от по-висок ред *derive f eps*, която намира първа производна на едноаргументната реална функция *f* с точност *eps*.

Как се изчислява първа производна:

![Alt text](first-derivative.png?raw=true "First Derivative")

Примери:

    (= ((derive (λ (x) (* 2 x x x)) 1e-3) 2) 24.0120019999992)
    (= ((derive (λ (x) (* 2 x x x)) 1e-6) 2) 24.000012004421478)

# Задача 6
Да се дефинира функция от по-висок ред *deriveN f n eps*, която намира n-та производна на едноаргументната реална функция *f* с точност *eps*.

Пример:

    (= ((deriveN (λ (x) (* 2 x x x)) 3 1e-3) 2) 12.000015203739167)

# Задача 7
Да се дефинират *derive-x f eps* и *derive-y f eps*, които намират първа частна производна (съответно на x и y) на двуаргументната реална функция *f(x,y)* с точност *eps*.

Как се изчисляваха частни производни:

![Alt text](partial-x.png?raw=true "First Derivative")

![Alt text](partial-y.png?raw=true "First Derivative")

Примери:

    (define (g x y) (+ (* x x x) (* x y) (* y y)))
    (= ((derive-x g 0.0001) 2 3) 15.000600010033338)
    (= ((derive-y g 0.0001) 2 3) 8.00009999998963)

# For home
Дефинирайте процедура *repeater str*, която получава като аргумент символен низ и връща анонимна функция на два аргумента - *count* и *glue* (число и низ). Оценката на обръщението към върнатата функция е низ, който се получава чрез count-кратно повтаряне на низа *str*, при което между всеки две съседни повторения на *str* стои низът *glue*.

Примери:

    (equal? ((repeater "I love Racket") 3 " ") "I love Racket I love Racket I love Racket")
    (equal? ((repeater "Quack") 5 "!") "Quack!Quack!Quack!Quack!Quack")