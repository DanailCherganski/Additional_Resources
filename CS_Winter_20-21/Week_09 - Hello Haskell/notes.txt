################################################################################
# Week_09 - Hello Haskell
################################################################################
 - general:
     - no more brackets :-)
        - VEEERY whitespace sensitive
     - no more prefix :-)
     - the term function is used instead of procedure
         - everything is a function now!
     - use camel case to name identifiers, i.e. myFunction
     - require = include
     - when passing negative numbers as parameters surround them in brackets
         - helper (-1)


 - comments:
     - use -- for single line comments
     - use {--} for multiline comments
         - only for human-readable text!

    
 - lambda:
     - (\ x -> x + 5)
     - (\ x y -> x + y)
     - (\ x y z -> x y z) (\ x y -> x + y) 5 6


 - lists:
     - [] = empty list
     - (range 1 6) = '(1 2 3 4 5) => [1 .. 5] = [1 2 3 4 5]
     - product [1 .. 5] = 120


 - types:
     - Int (using 32 bits), Integer (unbound)
     - Double, Rational
     - Bool (True False; && || not)
     - Char, String == [Char]
     - read the following: a = 5
     - strongly typed:
         - all types must be known at compile time
     - staticly typed:
         - if f returns Int, then f cannot return Double
     - type inference:
         - What is a declaration?
         - Did we have declarations in Racket?
         - We can have them in Haskell.
             - the compiler can guess the types, though just like in Racket
                 - this ability is called type inference
             - fname :: [type1 -> type2 -> ... ->]returnType

 - built-in functions:
    - min, max
    - fromIntegral :: Int -> Double
        - convert a whole number into its floating point equivalent
        - use when having to take square root of an integer
    - cond is now this: | <- what ??
    - sqrt is the same
    - expt is **
    - + - * / take only two arguments
        - / takes only floating point arguments
    - quotient = div
    - remainder = mod
    - != is now /=
